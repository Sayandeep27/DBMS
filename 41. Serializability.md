# ðŸ“˜ Serializability in DBMS

A **complete, beginnerâ€‘friendly, and professional guide** to **Serializability in Database Management Systems (DBMS)** â€” explained in **simple language**, with **clear tables, stepâ€‘byâ€‘step examples, and diagrams (via text)**.

This README is **GitHubâ€‘ready** and suitable for **exams, interviews, and deep conceptual understanding**.

---

## ðŸ“Œ What is Serializability?

**Serializability** is a concept used to **check whether a concurrent schedule is correct or not**.

ðŸ‘‰ A schedule is **serializable** if its **final result is the same as some serial schedule** (where transactions run one after another).

### ðŸ”¹ Why do we need Serializability?

When transactions run **concurrently**, problems can occur:

* Wrong balances
* Lost updates
* Inconsistent data

Serializability ensures:

* **Correctness**
* **Consistency**
* **Isolation**

---

## ðŸ“Œ Serial Schedule vs Concurrent Schedule

### âœ” Serial Schedule

Transactions execute **one by one**, no overlap.

```
T1 â†’ T2 â†’ T3
```

âœ” Always correct
âŒ Very slow

---

### âœ” Concurrent Schedule

Transactions **overlap in time**.

```
T1 and T2 execute together
```

âœ” Faster
âŒ Can be incorrect

ðŸ‘‰ **Serializability checks if a concurrent schedule is safe**.

---

## ðŸ“Œ Types of Serializability

There are **two main types**:

| Type                         | Based On                 |
| ---------------------------- | ------------------------ |
| **Conflict Serializability** | Conflicting operations   |
| **View Serializability**     | Readâ€‘write relationships |

---

# ðŸ”¹ 1. Conflict Serializability

## ðŸ“Œ What is Conflict?

Two operations **conflict** if:

1. They belong to **different transactions**
2. They access the **same data item**
3. At least **one is a WRITE**

### ðŸ”¥ Conflicting Operation Pairs

| Operation 1 | Operation 2 | Conflict? |
| ----------- | ----------- | --------- |
| R(A)        | R(A)        | âŒ No      |
| R(A)        | W(A)        | âœ… Yes     |
| W(A)        | R(A)        | âœ… Yes     |
| W(A)        | W(A)        | âœ… Yes     |

---

## ðŸ“Œ What is Conflict Serializability?

A schedule is **conflict serializable** if it can be transformed into a **serial schedule** by **swapping nonâ€‘conflicting operations only**.

---

## ðŸ“Œ How to Check Conflict Serializability?

We use a **Precedence Graph (Serialization Graph)**.

### ðŸ”¹ Steps

1. Create a node for each transaction
2. Draw an edge `Ti â†’ Tj` if:

   * Ti has a conflicting operation **before** Tj
3. Check for **cycle**

| Graph Result | Meaning                     |
| ------------ | --------------------------- |
| No cycle     | âœ… Conflict Serializable     |
| Cycle exists | âŒ Not Conflict Serializable |

---

## âœ… Example: Conflict Serializable Schedule

### Schedule

```
T1: R(A)      W(A)
T2:    R(A)        W(A)
```

### Conflicts

* T1 W(A) â†’ T2 R(A)

### Precedence Graph

```
T1 â†’ T2
```

âœ” No cycle
âœ” **Conflict Serializable**
âœ” Equivalent to serial schedule: `T1 â†’ T2`

---

## âŒ Example: NOT Conflict Serializable

### Schedule

```
T1: R(A)      W(A)
T2:    W(A) R(A)
```

### Conflicts

* T1 R(A) â†’ T2 W(A)
* T2 W(A) â†’ T1 R(A)

### Precedence Graph

```
T1 â†’ T2
â†‘     â†“
â””â”€â”€â”€â”€â”€â”˜
```

âŒ Cycle exists
âŒ **Not Conflict Serializable**

---

# ðŸ”¹ 2. View Serializability

## ðŸ“Œ What is View Serializability?

A schedule is **view serializable** if it produces the **same readâ€‘write view** as some serial schedule.

It focuses on:

1. **Who reads whose value**
2. **Final write** of each data item

---

## ðŸ“Œ Conditions for View Serializability

A schedule S is view serializable if there exists a serial schedule S' such that:

1. **Initial Read Rule**

   * If Ti reads the initial value of A in S, it must do so in S'

2. **Read From Rule**

   * If Ti reads A written by Tj in S, same must happen in S'

3. **Final Write Rule**

   * The transaction performing the **final write** must be the same

---

## âœ… Example: View Serializable but NOT Conflict Serializable

### Schedule

```
T1:      W(A)
T2: R(A)      W(A)
T3:    R(A)
```

### Observations

* T2 reads A written by T1
* T3 reads A written by T1
* Final write on A by T2

âœ” Preserves readâ€‘from relations
âœ” Same final write

âœ… **View Serializable**
âŒ **Not Conflict Serializable**

---

## ðŸ“Œ Why Conflict Serializability is Preferred?

| Reason        | Explanation                  |
| ------------- | ---------------------------- |
| Easy to check | Uses graph & cycle detection |
| Efficient     | Polynomial time              |
| Practical     | Used in real DBMS            |

ðŸ‘‰ View serializability is **NPâ€‘Complete** (very expensive).

---

## ðŸ“Œ Relationship Between Them

```
Conflict Serializable âŠ† View Serializable
```

* Every conflict serializable schedule is view serializable
* Not every view serializable schedule is conflict serializable

---

## ðŸ“Œ Summary Table

| Feature         | Conflict Serializability | View Serializability |
| --------------- | ------------------------ | -------------------- |
| Based on        | Conflicting operations   | Readâ€‘write view      |
| Checking method | Precedence graph         | Readâ€‘from analysis   |
| Complexity      | Easy                     | Hard                 |
| Used in DBMS    | âœ… Yes                    | âŒ Rare               |

---

## ðŸŽ¯ Key Exam Points

* Serializability ensures correctness of concurrent schedules
* Conflict serializability uses **precedence graph**
* Cycle = NOT serializable
* View serializability is more general but expensive

---

## âœ… Final Takeaway

> **If a concurrent schedule behaves like a serial one, it is safe.**

Serializability is the **core correctness criterion** in transaction management.

---

ðŸ“Œ *This README is ready for GitHub, exams, and interviews.*
