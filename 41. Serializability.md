# ğŸ“˜ Schedule and Serializability in DBMS

---

## â“ What is a Schedule in DBMS?

A **schedule** is the **order in which operations of transactions are executed** in a database.

Operations are mainly:

* `R(X)` â†’ Read data item X
* `W(X)` â†’ Write data item X

A schedule shows **how multiple transactions are interleaved by the DBMS**.

---

## â“ What is Serializability?

**Serializability** is a **correctness rule for concurrent execution of transactions**.

### Definition (in simple words)

A schedule is **serializable** if:

> Its final result is the same as executing the transactions **one by one (serially)**, even though they may be running together.

So:

* Transactions may run **concurrently**
* But the result must look like a **serial execution**

---

## â“ Why Do We Need Serializability?

Databases allow **concurrent execution** to improve:

* Performance
* CPU utilization
* Response time

But concurrency can cause problems:

* Dirty read
* Lost update
* Inconsistent data

Serializability ensures:

* Data consistency
* Correct final result
* **ACID Isolation property**

### In short:

> **Serializability = Safety + Performance**

---

## ğŸ”¹ Serial Schedule

### What is a Serial Schedule?

A **serial schedule** executes:

* One transaction **completely**
* Then the next transaction starts
* **No interleaving at all**

---

### Example

Assume:

* Initial balance **A = 100**

Transactions:

```
T1: Read(A)
    A = A + 50
    Write(A)

T2: Read(A)
    A = A - 30
    Write(A)
```

### Serial Schedule (T1 â†’ T2)

| Step | Operation        | A   |
| ---: | ---------------- | --- |
|    1 | T1: Read(A)      | 100 |
|    2 | T1: Write(A=150) | 150 |
|    3 | T2: Read(A)      | 150 |
|    4 | T2: Write(A=120) | 120 |

**Final value of A = 120**

---

### Characteristics of Serial Schedule

* Very safe
* Very simple
* But slow
* Poor resource utilization

---

## ğŸ”¹ Concurrent Schedule

### What is a Concurrent Schedule?

A **concurrent schedule**:

* Executes multiple transactions **at the same time**
* Operations are **interleaved**
* This is how **real databases work**

---

### Example of Concurrent Schedule

Initial balance **A = 100**

| Step | Operation        | A   |
| ---: | ---------------- | --- |
|    1 | T1: Read(A)      | 100 |
|    2 | T2: Read(A)      | 100 |
|    3 | T1: Write(A=150) | 150 |
|    4 | T2: Write(A=70)  | 70  |

**Final value of A = 70**

#### Problem here:

* Final result is **wrong**
* Data inconsistency occurs

âŒ **This schedule is NOT serializable**

---

## ğŸ”¹ Serializability in Concurrent Schedules

A concurrent schedule is allowed **only if**:

> It produces the same result as **some serial schedule**

---

### Example of Serializable Concurrent Schedule

| Step | Operation        | A   |
| ---: | ---------------- | --- |
|    1 | T1: Read(A)      | 100 |
|    2 | T1: Write(A=150) | 150 |
|    3 | T2: Read(A)      | 150 |
|    4 | T2: Write(A=120) | 120 |

This is:

* Concurrent
* Interleaved
* Result = **120**
* Same as serial **T1 â†’ T2**

âœ… **Serializable**

---

## ğŸ‘€ Visual Understanding

### Serial Schedule vs Concurrent Schedule

| Feature        | Serial Schedule           | Concurrent Schedule       |
| -------------- | ------------------------- | ------------------------- |
| Execution      | One transaction at a time | Multiple at the same time |
| Interleaving   | No                        | Yes                       |
| Speed          | Slow                      | Fast                      |
| Resource usage | Poor                      | Efficient                 |
| Safety         | Always safe               | Safe only if serializable |
| Real-world use | Rare                      | Very common               |

---

## ğŸ§¾ Final Summary

* Serializability guarantees **correctness** in concurrent execution
* Serial schedule is **always correct** but inefficient
* Concurrent schedule is **efficient but risky**
* Serializable concurrent schedule gives the **best of both worlds**

### Important Rule

> **All serial schedules are serializable**
> **But not all concurrent schedules are serializable**

---

# ğŸ”· Types of Serializability in DBMS

There are **two main types of serializability**:

* Conflict Serializability
* View Serializability

Both try to answer one core question:

> â€œIs this concurrent schedule equivalent to some serial schedule?â€

---

## 1ï¸âƒ£ Conflict Serializability

### What is Conflict Serializability?

A schedule is **conflict serializable** if:

> It can be converted into a serial schedule by **swapping non-conflicting operations**.

---

### What is a Conflict?

Two operations **conflict** if **all three conditions are true**:

1. They belong to **different transactions**
2. They access the **same data item**
3. At least **one of them is a WRITE**

---

### Conflicting Operation Pairs

| Operation 1 | Operation 2 | Conflict? |
| ----------- | ----------- | --------- |
| Read(X)     | Read(X)     | âŒ No      |
| Read(X)     | Write(X)    | âœ… Yes     |
| Write(X)    | Read(X)     | âœ… Yes     |
| Write(X)    | Write(X)    | âœ… Yes     |

---

### Idea Behind Conflict Serializability

* Only **conflicting operations** matter
* If we can reorder **non-conflicting operations**
* And finally get a **serial order**

â†’ the schedule is **conflict serializable**

---

### Example 1: Conflict Serializable Schedule

Initial value: **A = 100**

Transactions:

```
T1: R(A)  W(A)
T2: R(A)  W(A)
```

Schedule S:

| Step | Operation |
| ---: | --------- |
|    1 | T1: R(A)  |
|    2 | T1: W(A)  |
|    3 | T2: R(A)  |
|    4 | T2: W(A)  |

This is already equivalent to **serial T1 â†’ T2**

* No conflicting order violation

âœ… **Conflict Serializable**

---

### Example 2: NOT Conflict Serializable

Schedule S:

| Step | Operation |
| ---: | --------- |
|    1 | T1: R(A)  |
|    2 | T2: R(A)  |
|    3 | T2: W(A)  |
|    4 | T1: W(A)  |

Conflicts:

* T1 â†’ T2 (because R(A) before W(A))
* T2 â†’ T1 (because W(A) before W(A))

This creates a **cycle**.

So:

âŒ Cannot convert to serial
âŒ **Not Conflict Serializable**

---

### How DBMS Checks Conflict Serializability

Using a **Precedence (Serialization) Graph**:

* Node = Transaction
* Edge Ti â†’ Tj if Ti must occur before Tj

Rules:

* If **cycle exists** â†’ âŒ NOT conflict serializable
* If **no cycle** â†’ âœ… conflict serializable

---

## 2ï¸âƒ£ View Serializability

### What is View Serializability?

A schedule is **view serializable** if:

* It produces the **same final result** as some serial schedule
* Even if **conflicts differ**

It is **less strict** than conflict serializability.

---

### Conditions for View Serializability

Two schedules are **view equivalent** if:

#### 1ï¸âƒ£ Initial Read Rule

If a transaction reads an initial value in one schedule, it must read the initial value in the other.

#### 2ï¸âƒ£ Read-From Rule

If Tj reads X written by Ti in one schedule, it must read from Ti in the other schedule.

#### 3ï¸âƒ£ Final Write Rule

The last write on X must be by the **same transaction**.

---

### Example: View Serializable but NOT Conflict Serializable

Initial value: **A = 100**

Schedule S:

| Step | Operation |
| ---: | --------- |
|    1 | T1: W(A)  |
|    2 | T2: W(A)  |
|    3 | T1: W(A)  |

* Final write on A is by **T1**

This schedule:

* Has writeâ€“write conflicts
* Has cycle

âŒ Not conflict serializable

But:

* Final result matches serial **T2 â†’ T1**
* Read rules satisfied

So:

âœ… **View Serializable**
âŒ **Not Conflict Serializable**

---

### Why View Serializability is Important

Some correct schedules:

* Cannot be proved using conflicts
* But still produce correct results

View serializability:

* Accepts more schedules
* Is more powerful

---

## ğŸ”— Relationship Between the Two

| Property            | Conflict Serializability | View Serializability |
| ------------------- | ------------------------ | -------------------- |
| Strictness          | More strict              | Less strict          |
| Easy to check       | âœ… Yes (graph)            | âŒ No (complex)       |
| Allows blind writes | âŒ No                     | âœ… Yes                |
| Practical use       | Very high                | Mostly theoretical   |

---

## â­ Important Rule (Very Common Exam Question)

> **Every conflict serializable schedule is view serializable**
> **But NOT every view serializable schedule is conflict serializable**

---

## ğŸ§  One-Line Intuition (Easy to Remember)

**Conflict Serializability**
â†’ â€œOrder of conflicting operations must match a serial orderâ€

**View Serializability**
â†’ â€œWho reads from whom and who writes last must match a serial orderâ€

---

## ğŸ§¾ Final Summary

### Conflict Serializability

* Uses conflicts
* Checked via graph
* Used in real DBMS

### View Serializability

* Uses final results and read relations
* More flexible
* Hard to test, rarely implemented
