# ğŸ“˜ How to Normalize a Table in DBMS

A **step-by-step, beginner-friendly guide** to database normalization with **clear explanations, tables, and examples**.
This README is **GitHubâ€‘ready** and suitable for **DBMS exams, interviews, and practical design**.

---

## ğŸ“Œ What is Normalization?

**Normalization** is the process of **organizing data in a database** to:

* Reduce **data redundancy** (duplicate data)
* Avoid **update, insert, and delete anomalies**
* Improve **data consistency and integrity**

In normalization, we usually **break (decompose) one large table into two or more smaller tables**.

---

## ğŸ§­ Before You Start Normalization

Always identify the following:

* **Attributes** (columns)
* **Functional Dependencies (FDs)**
* **Candidate Keys (CK)**
* **Prime attributes** â†’ part of a candidate key
* **Nonâ€‘prime attributes** â†’ not part of any candidate key

---

## ğŸªœ Steps to Normalize a Table

We normalize a table **stepâ€‘byâ€‘step** through different **Normal Forms**.

---

## âœ… Step 1: Identify Attributes, Keys & Functional Dependencies

### ğŸ“„ Example Table: `STUDENT_COURSE`

| StudentID | StudentName | CourseID | CourseName | Instructor |
| --------- | ----------- | -------- | ---------- | ---------- |
| S1        | Rahul       | C1       | DBMS       | Prof. A    |
| S1        | Rahul       | C2       | OS         | Prof. B    |
| S2        | Anita       | C1       | DBMS       | Prof. A    |

### ğŸ”‘ Candidate Key

* `(StudentID, CourseID)`

### ğŸ“Œ Functional Dependencies

```
StudentID â†’ StudentName
CourseID â†’ CourseName, Instructor
(StudentID, CourseID) â†’ all attributes
```

---

## ğŸ¥‡ Step 2: First Normal Form (1NF)

### ğŸ“˜ Rule

A table is in **1NF** if:

* Each cell contains **atomic (indivisible) values**
* There is a **primary key**

### âŒ Not in 1NF Example

| StudentID | StudentName | Courses  |
| --------- | ----------- | -------- |
| S1        | Rahul       | DBMS, OS |

âŒ `Courses` is **multiâ€‘valued**

### âœ… Convert to 1NF

| StudentID | StudentName | Course |
| --------- | ----------- | ------ |
| S1        | Rahul       | DBMS   |
| S1        | Rahul       | OS     |

âœ” Now every value is **atomic**

---

## ğŸ¥ˆ Step 3: Second Normal Form (2NF)

### ğŸ“˜ Rule

A table is in **2NF** if:

* It is already in **1NF**
* **No Partial Dependency** exists

ğŸ“Œ **Partial Dependency**:

> When a **nonâ€‘prime attribute** depends on **part of a composite key**

---

### âŒ Partial Dependency Example

Candidate Key: `(StudentID, CourseID)`

```
StudentID â†’ StudentName
```

Here, `StudentName` depends only on `StudentID` âŒ

---

### âœ… Decompose to Remove Partial Dependency

#### STUDENT Table

| StudentID | StudentName |
| --------- | ----------- |
| S1        | Rahul       |
| S2        | Anita       |

#### COURSE_ENROLLMENT Table

| StudentID | CourseID | CourseName | Instructor |
| --------- | -------- | ---------- | ---------- |

âœ” Now table is in **2NF**

---

## ğŸ¥‰ Step 4: Third Normal Form (3NF)

### ğŸ“˜ Rule

A table is in **3NF** if:

* It is in **2NF**
* **No Transitive Dependency** exists

ğŸ“Œ **Transitive Dependency**:

> Nonâ€‘prime attribute depends on another nonâ€‘prime attribute

---

### âŒ Transitive Dependency Example

```
CourseID â†’ CourseName
CourseName â†’ Instructor
```

So:

```
CourseID â†’ Instructor (indirectly)
```

âŒ Transitive Dependency exists

---

### âœ… Decompose to Remove Transitive Dependency

#### COURSE Table

| CourseID | CourseName |
| -------- | ---------- |
| C1       | DBMS       |
| C2       | OS         |

#### INSTRUCTOR Table

| CourseName | Instructor |
| ---------- | ---------- |
| DBMS       | Prof. A    |
| OS         | Prof. B    |

âœ” Now database is in **3NF**

---

## ğŸ† Step 5: Boyceâ€‘Codd Normal Form (BCNF)

### ğŸ“˜ Rule

A table is in **BCNF** if:

> For every functional dependency **X â†’ Y**, **X must be a Candidate Key**

BCNF is **stronger than 3NF**

---

### âŒ BCNF Violation Example

| Student | Subject | Teacher |
| ------- | ------- | ------- |

```
Subject â†’ Teacher
(Student, Subject) â†’ Teacher
```

Here, `Subject` is **not a candidate key** âŒ

---

### âœ… Decompose to BCNF

#### SUBJECT_TEACHER Table

| Subject | Teacher |
| ------- | ------- |

#### STUDENT_SUBJECT Table

| Student | Subject |
| ------- | ------- |

âœ” Now both tables are in **BCNF**

---

## ğŸ” Step 6: Lossless Decomposition

### ğŸ“˜ Rule

When decomposing tables:

* **No data should be lost**
* Tables must be joined using a **common attribute that is a Candidate Key**

This ensures **lossless join**

---

## ğŸ§  Summary Table

| Normal Form | Main Condition                     |
| ----------- | ---------------------------------- |
| **1NF**     | Atomic values + Primary key        |
| **2NF**     | No partial dependency              |
| **3NF**     | No transitive dependency           |
| **BCNF**    | LHS of every FD is a candidate key |

---

## ğŸ¯ Key Takeaways

* Always **analyze functional dependencies first**
* Normalize **step by step**
* Decompose only when a rule is violated
* Prefer **BCNF**, but **3NF** is acceptable if dependency preservation is required

---

## ğŸ“¥ Ready to Use

This README is:

* âœ… Examâ€‘ready
* âœ… Interviewâ€‘ready
* âœ… GitHubâ€‘ready

You can **download, copy, or edit** it directly.

---

ğŸ’¡ *If you want next topics like* **Normalization numericals**, **lossy vs lossless join**, or **dependency preservation**, just tell me.
