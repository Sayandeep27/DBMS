# ğŸ“˜ Database Recovery Management (DBMS)

A **complete, beginnerâ€‘friendly, and professional guide** to **Database Recovery Management** in **DBMS** â€” explained in **simple language**, with **clear examples, tables, and diagrams (textual)**.
This README is **GitHubâ€‘ready** and suitable for **exams, interviews, and realâ€‘world understanding**.

---

## ğŸ“Œ What is Database Recovery Management?

**Database Recovery Management** is the part of DBMS that ensures:

* Data is **not lost** due to failures
* Database remains **consistent**
* Committed transactions are **permanently saved**
* Uncommitted or faulty transactions are **rolled back safely**

In short:

> **Recovery management brings the database back to a correct state after a failure.**

---

## ğŸ¯ Why is Recovery Management Needed?

Failures are unavoidable in real systems:

* Power failure
* System crash
* Disk crash
* Software bugs
* Sudden shutdown

Without recovery management:

* Data may become **corrupted**
* Database may reach an **inconsistent state**
* Users may lose **critical information**

---

## ğŸ§± Types of Database Failures

DBMS failures are mainly classified into **three types**:

| Failure Type        | Affects                     | Example                    |
| ------------------- | --------------------------- | -------------------------- |
| Transaction Failure | Single transaction          | Invalid input, logic error |
| System Failure      | Entire system (memory lost) | Power failure              |
| Media Failure       | Disk / storage              | Hard disk crash            |

Letâ€™s understand each one clearly ğŸ‘‡

---

## 1ï¸âƒ£ Transaction Failure

### ğŸ” What is Transaction Failure?

A **transaction failure** occurs when **a single transaction cannot complete successfully**.

The DBMS must **undo** the effects of that transaction.

---

### ğŸ”¹ Causes of Transaction Failure

* Invalid input data
* Arithmetic errors (divide by zero)
* Logical errors in SQL
* Deadlock or timeout
* Explicit rollback by user

---

### ğŸ§  Example

```
Transaction T1:
Read(A)
A = A - 100
Write(A)
ERROR occurs before COMMIT
```

Result:

* Money is deducted
* But transaction never commits

ğŸ‘‰ DBMS **UNDOES** the changes of T1

---

### âœ… Recovery Action

* **Undo (Rollback)** the failed transaction
* Restore old values from log

---

## 2ï¸âƒ£ System Failure

### ğŸ” What is System Failure?

A **system failure** happens when:

* The **entire system crashes**
* Main memory (RAM) contents are **lost**
* Disk data remains **intact**

---

### ğŸ”¹ Causes of System Failure

* Power failure
* OS crash
* DBMS crash
* CPU failure

---

### ğŸ§  Example

```
T1: Transfer â‚¹100 (COMMITTED)
T2: Withdraw â‚¹50 (NOT COMMITTED)

Power failure occurs
```

After restart:

* T1 must be **REDONE** (ensure changes exist)
* T2 must be **UNDONE** (rollback incomplete transaction)

---

### âœ… Recovery Action

* **Redo committed transactions**
* **Undo uncommitted transactions**

---

## 3ï¸âƒ£ Media Failure

### ğŸ” What is Media Failure?

A **media failure** occurs when:

* **Disk or storage device is damaged**
* Data on disk is **lost or corrupted**

---

### ğŸ”¹ Causes of Media Failure

* Hard disk crash
* Head crash
* Bad sectors
* Natural disasters
* File system corruption

---

### ğŸ§  Example

```
Hard disk containing database crashes
All data files are lost
```

---

### âœ… Recovery Action

* Restore database from **backup**
* Apply **redo logs** to reach latest state

---

## ğŸ”„ Recovery Process in DBMS

Modern DBMS (like ARIES) uses **three recovery phases**:

1. Analysis Phase
2. Redo Phase
3. Undo Phase

---

## ğŸŸ¡ Phase 1: Analysis Phase

### ğŸ¯ Purpose

* Identify:

  * Which transactions were **active** at crash time
  * Which transactions were **committed**
  * Which pages were **dirty**

---

### ğŸ” What Happens?

* DBMS scans the **log file** from last checkpoint
* Builds:

  * **Transaction Table**
  * **Dirty Page Table**

---

### ğŸ§  Example

```
Checkpoint
T1 START
T2 START
T1 COMMIT
System Crash
```

Analysis finds:

* T1 â†’ committed
* T2 â†’ active (needs UNDO)

---

## ğŸ”µ Phase 2: Redo Phase

### ğŸ¯ Purpose

* Reapply **all necessary changes** to ensure durability

---

### ğŸ” What Happens?

* DBMS replays log records
* Ensures committed transactionsâ€™ updates are present

---

### ğŸ§  Example

```
T1: A = A - 100 (COMMITTED)
But disk write not completed before crash
```

ğŸ‘‰ REDO reapplies the update

---

### ğŸ”‘ Key Point

> Redo is **idempotent** (safe to apply multiple times)

---

## ğŸ”´ Phase 3: Undo Phase

### ğŸ¯ Purpose

* Remove effects of **incomplete transactions**

---

### ğŸ” What Happens?

* DBMS scans log **backwards**
* Rolls back uncommitted transactions
* Writes compensation log records (CLRs)

---

### ğŸ§  Example

```
T2: B = B + 50
Crash before COMMIT
```

ğŸ‘‰ Undo restores old value of B

---

## ğŸ› ï¸ Recovery Techniques in DBMS

There are **three major recovery techniques**:

1. Backup and Restore
2. Logging (Writeâ€‘Ahead Logging)
3. Shadow Paging

---

## 1ï¸âƒ£ Backup and Restore

### ğŸ” What is Backup?

A **backup** is a **copy of database** stored at a safe location.

---

### ğŸ”„ How Restore Works

1. Database crashes
2. Restore latest backup
3. Apply redo logs

---

### ğŸ§  Example

```
Backup taken at 10:00 AM
Crash at 11:00 AM
```

Recovery:

* Restore 10:00 AM backup
* Redo transactions from 10:00 to 11:00

---

### âœ… Advantages

* Simple
* Reliable for media failure

### âŒ Disadvantages

* Backup may be old
* Recovery time can be high

---

## 2ï¸âƒ£ Logging (Writeâ€‘Ahead Logging â€“ WAL)

### ğŸ” What is Logging?

**Log file** records all database changes **before they are applied**.

---

### ğŸ“œ Log Record Format

```
<Transaction ID, Data Item, Old Value, New Value>
```

---

### ğŸ”‘ Writeâ€‘Ahead Logging Rule

> **Log must be written to disk BEFORE data is written to disk**

---

### ğŸ§  Example

```
Log: <T1, A, 500, 400>
Disk write of A happens later
```

If crash occurs:

* Use log to REDO or UNDO safely

---

### âœ… Advantages

* Supports undo & redo
* Fast recovery
* Widely used (ARIES)

### âŒ Disadvantages

* Log management overhead

---

## 3ï¸âƒ£ Shadow Paging

### ğŸ” What is Shadow Paging?

* Maintain **two page tables**:

  * Shadow Page Table (stable)
  * Current Page Table (working)

---

### ğŸ”„ How It Works

* Updates are written to **new pages**
* Original pages remain unchanged
* On commit â†’ switch page table pointer

---

### ğŸ§  Example

```
Original Page â†’ unchanged
New Page â†’ updated values

Commit â†’ point to new page
Crash â†’ shadow page still safe
```

---

### âœ… Advantages

* No undo/redo needed
* Simple recovery

### âŒ Disadvantages

* Poor concurrency
* High memory overhead
* Not scalable

---

## ğŸ“Š Comparison of Recovery Techniques

| Technique        | Undo | Redo | Used Today    |
| ---------------- | ---- | ---- | ------------- |
| Backup & Restore | âŒ    | âœ…    | Yes           |
| Logging (WAL)    | âœ…    | âœ…    | âœ… Most Common |
| Shadow Paging    | âŒ    | âŒ    | Rare          |

---

## ğŸ§  Final Summary

* Recovery management ensures **atomicity & durability**
* Failures:

  * Transaction
  * System
  * Media
* Recovery phases:

  * Analysis
  * Redo
  * Undo
* Most practical technique:

  * **Logging with Backup**

---

## âœ… Examâ€‘Friendly Oneâ€‘Line Definition

> **Database recovery management restores the database to a consistent state after failures using logging, backups, and recovery algorithms.**

---

ğŸ“Œ **You can now Copy, Edit, or Download this README for GitHub or exam preparation.**

If you want:

* ARIES algorithm explained stepâ€‘byâ€‘step
* Numericals on recovery
* MCQs or interview Q&A

Just tell me ğŸ‘
