# ğŸ“˜ Decomposition of a Relation in DBMS

A **complete, beginnerâ€‘friendly, and examâ€‘oriented guide** to **Decomposition in Database Management Systems (DBMS)** â€” explained in **simple language** with **clear tables, examples, and rules**.
This README is **GitHubâ€‘ready** and suitable for **study, revision, and interviews**.

---

## ğŸ“Œ What is Decomposition in DBMS?

**Decomposition** is the process of **breaking a single large table (relation)** into **two or more smaller tables** to:

* Reduce **data redundancy**
* Avoid **update, insert, and delete anomalies**
* Achieve **higher normal forms** (2NF, 3NF, BCNF, etc.)
* Make the database **more organized and reliable**

ğŸ‘‰ After decomposition, **all original data must be recoverable** by joining the smaller tables.

---

## ğŸ” Why Do We Need Decomposition?

Consider this table:

### STUDENT_COURSE

| StudentID | StudentName | CourseID | CourseName | Instructor |
| --------- | ----------- | -------- | ---------- | ---------- |
| S1        | Rahul       | C1       | DBMS       | Ankit      |
| S1        | Rahul       | C2       | OS         | Neha       |
| S2        | Priya       | C1       | DBMS       | Ankit      |

### âŒ Problems

* **Redundancy**: StudentName and Instructor repeat
* **Update anomaly**: Changing instructor name needs multiple updates
* **Insert anomaly**: Cannot add a course without a student
* **Delete anomaly**: Deleting last student removes course info

ğŸ‘‰ Solution: **Decomposition**

---

## ğŸ§© Decomposition â€“ Basic Idea

We split the table into smaller relations:

### STUDENT

| StudentID | StudentName |
| --------- | ----------- |
| S1        | Rahul       |
| S2        | Priya       |

### COURSE

| CourseID | CourseName | Instructor |
| -------- | ---------- | ---------- |
| C1       | DBMS       | Ankit      |
| C2       | OS         | Neha       |

### ENROLLMENT

| StudentID | CourseID |
| --------- | -------- |
| S1        | C1       |
| S1        | C2       |
| S2        | C1       |

âœ” Redundancy removed
âœ” Data integrity improved

---

## ğŸ”‘ Types of Decomposition in DBMS

There are **three important concepts**:

1. **Lossless Decomposition**
2. **Lossy Decomposition**
3. **Dependency Preserving Decomposition**

Weâ€™ll explain **each with rules and examples**.

---

## âœ… 1. Lossless Decomposition

### ğŸ“– Definition

A decomposition is **lossless** if:

> After decomposing a relation, we can **reconstruct the original relation exactly** using **JOIN** without losing information.

---

### ğŸ§  Key Rule (Most Important for Exams)

A decomposition of R into R1 and R2 is **lossless** if **either**:

```
R1 âˆ© R2 â†’ R1
OR
R1 âˆ© R2 â†’ R2
```

ğŸ‘‰ Common attribute must be a **key** in at least one table.

---

### ğŸ“Š Example of Lossless Decomposition

#### Original Relation

R(A, B, C)

Functional Dependency:

```
A â†’ B
```

#### Decompose Into:

* R1(A, B)
* R2(A, C)

#### Check

* Common attribute = A
* A â†’ B, so A is key of R1

âœ” **Lossless Decomposition**

---

### ğŸ“Œ Table Example

#### EMPLOYEE

| EmpID | EmpName | Dept |
| ----- | ------- | ---- |
| E1    | Ravi    | IT   |
| E2    | Neha    | HR   |

FD:

```
EmpID â†’ EmpName, Dept
```

#### Decomposition

**EMP**

| EmpID | EmpName |
| ----- | ------- |

**DEPT**

| EmpID | Dept |
| ----- | ---- |

âœ” Join on EmpID gives original table

---

## âŒ 2. Lossy Decomposition

### ğŸ“– Definition

A decomposition is **lossy** if:

> Joining the decomposed tables **does NOT restore the original relation correctly**.

Information is **lost or incorrect tuples are generated**.

---

### ğŸ“Š Example of Lossy Decomposition

#### Original Relation

R(A, B, C)

No functional dependency between attributes.

#### Decompose Into:

* R1(A, B)
* R2(B, C)

#### Problem

* Common attribute = B
* B is NOT a key of R1 or R2

âŒ **Lossy Decomposition**

---

### ğŸ“Œ Table Example

#### R

| A | B | C |
| - | - | - |
| 1 | 2 | 3 |
| 4 | 2 | 5 |

#### Decomposed Tables

**R1(A, B)**

| A | B |
| - | - |
| 1 | 2 |
| 4 | 2 |

**R2(B, C)**

| B | C |
| - | - |
| 2 | 3 |
| 2 | 5 |

#### After JOIN

Extra incorrect rows appear âŒ

---

## ğŸ”— 3. Dependency Preserving Decomposition

### ğŸ“– Definition

A decomposition is **dependency preserving** if:

> **All functional dependencies** of the original relation can be **checked without joining tables**.

---

### ğŸ§  Why Is This Important?

* Improves **data integrity enforcement**
* Avoids costly joins for validation
* Preferred in real databases

---

### ğŸ“Š Example of Dependency Preserving Decomposition

#### Original Relation

R(A, B, C)

Functional Dependencies:

```
A â†’ B
B â†’ C
```

#### Decompose Into:

* R1(A, B)
* R2(B, C)

âœ” A â†’ B checked in R1
âœ” B â†’ C checked in R2

âœ” **Dependency Preserving**

---

### âš ï¸ Important Note

* **BCNF decomposition** may be **lossless but NOT dependency preserving**
* **3NF decomposition** ensures **both lossless and dependency preserving**

---

## ğŸ†š Comparison Table

| Type                  | Information Loss | Dependency Check | Preferred     |
| --------------------- | ---------------- | ---------------- | ------------- |
| Lossless              | âŒ No             | âœ” Yes            | Mandatory     |
| Lossy                 | âœ” Yes            | âŒ No             | Never used    |
| Dependency Preserving | âŒ No             | âœ” Yes            | Best practice |

---

## ğŸ“ Exam Tips (Very Important)

* Always **ensure lossless decomposition**
* Write the **intersection rule** clearly
* Mention **functional dependencies**
* Use **simple tables** in answers
* Lossy decomposition is **never acceptable**

---

## âœ… Final Summary

* **Decomposition** splits a large table into smaller ones
* **Lossless** â†’ No information loss (mandatory)
* **Lossy** â†’ Data loss (invalid)
* **Dependency Preserving** â†’ Easy FD checking (ideal)

---

ğŸ“Œ *If you want next:*
âœ” Stepâ€‘byâ€‘step **lossless check problems**
âœ” **3NF vs BCNF decomposition examples**
âœ” **Examâ€‘ready solved questions**

Just tell me ğŸ‘
