# ğŸ“˜ Concurrency Control Mechanisms in DBMS

A **complete, beginnerâ€‘friendly, and professional guide** to **Concurrency Control Mechanisms in Database Management Systems (DBMS)** â€” explained in **simple language**, with **clear examples, tables, and schedules**, ready to **download and use on GitHub**.

---

## ğŸ“Œ Why Do We Need Concurrency Control?

In a **multiâ€‘user database**, many transactions execute **at the same time**.

Without control, this can cause:

* Wrong results
* Data inconsistency
* Loss of updates
* Violation of ACID properties

**Concurrency Control** ensures that:

* Transactions execute **correctly**
* Database remains **consistent**
* Results are the same as some **serial execution**

---

## ğŸ§  What Is a Concurrency Control Mechanism?

A **Concurrency Control Mechanism** is a **set of rules and techniques** used by the DBMS to **manage simultaneous execution of transactions** so that **isolation and consistency** are preserved.

---

## ğŸ”‘ Main Types of Concurrency Control Mechanisms

| No  | Mechanism                               |
| --- | --------------------------------------- |
| 1ï¸âƒ£ | Lockâ€‘Based Protocols                    |
| 2ï¸âƒ£ | Timestampâ€‘Based Protocols               |
| 3ï¸âƒ£ | Optimistic Concurrency Control (OCC)    |
| 4ï¸âƒ£ | Multiversion Concurrency Control (MVCC) |

---

# 1ï¸âƒ£ Lockâ€‘Based Concurrency Control

## ğŸ” Basic Idea

* A **lock** is applied on data before using it
* Other transactions must **wait** until the lock is released

Two lock types:

* **Shared Lock (S)** â†’ Read only
* **Exclusive Lock (X)** â†’ Read + Write

---

## ğŸ§ª Example

```
T1: Read(A)
T2: Write(A)
```

If T1 is reading A, T2 must **wait** until T1 finishes.

---

## ğŸ“Œ Twoâ€‘Phase Locking (2PL)

### Rule

1. **Growing Phase** â†’ Locks can be acquired
2. **Shrinking Phase** â†’ Locks can be released
3. No new lock after releasing any lock

### Why?

Guarantees **conflict serializability**

---

### ğŸ§¾ Example Schedule

```
T1: Lock(A)
T1: Read(A)
T1: Lock(B)
T1: Write(B)
T1: Unlock(A)
T1: Unlock(B)
```

---

## ğŸ”’ Strict 2PL

### Rule

* All **exclusive locks** are released **only after commit**

### Advantage

* Prevents **cascading rollback**

---

## ğŸ” Rigorous 2PL

### Rule

* Both **shared and exclusive locks** released **after commit**

### Advantage

* Strong isolation

---

## ğŸ›‘ Conservative 2PL

### Rule

* Acquire **all required locks before execution starts**

### Advantage

* **No deadlock**

### Disadvantage

* Low concurrency

---

# 2ï¸âƒ£ Timestampâ€‘Based Concurrency Control

## â±ï¸ Basic Idea

* Each transaction gets a **timestamp**
* Operations must follow **timestamp order**

---

## ğŸ“Œ Timestamp Ordering Rules

| Condition            | Action            |
| -------------------- | ----------------- |
| Read old data        | Allowed           |
| Write violates order | Abort transaction |

---

## ğŸ§ª Example

```
T1 (TS=5): Write(A)
T2 (TS=10): Read(A)
```

âœ” Allowed because 5 < 10

```
T2: Write(A)
T1: Read(A)
```

âŒ T1 aborted because it violates timestamp order

---

## âœ… Advantages

* No deadlock
* Simple logic

## âŒ Disadvantages

* Frequent rollbacks

---

# 3ï¸âƒ£ Optimistic Concurrency Control (OCC)

## ğŸ¤ Basic Idea

* Assume **conflicts are rare**
* Allow free execution
* Check conflicts **only at commit time**

---

## ğŸ§© Three Phases of OCC

1ï¸âƒ£ **Read Phase** â€“ Read and modify local copy
2ï¸âƒ£ **Validation Phase** â€“ Check conflicts
3ï¸âƒ£ **Write Phase** â€“ Commit if valid

---

## ğŸ§ª Example

Two transactions read same data:

* If both only read â†’ âœ” commit
* If both write â†’ âŒ one aborts

---

## âœ… Advantages

* High performance in lowâ€‘conflict systems

## âŒ Disadvantages

* High rollback if conflicts are frequent

---

# 4ï¸âƒ£ Multiversion Concurrency Control (MVCC)

## ğŸ“š Basic Idea

* Maintain **multiple versions** of data
* Readers and writers **do not block each other**

---

## ğŸ§ª Example

| Transaction | Version Used |
| ----------- | ------------ |
| T1 Read     | Old version  |
| T2 Write    | New version  |

Both execute **simultaneously**

---

## ğŸ§  How MVCC Works

* Each write creates a **new version**
* Read uses **snapshot** based on timestamp

---

## âœ… Advantages

* High concurrency
* No readâ€‘write blocking

## âŒ Disadvantages

* Extra storage
* Version management overhead

---

## ğŸ” Comparison Table

| Mechanism  | Deadlock | Rollback | Performance         |
| ---------- | -------- | -------- | ------------------- |
| Lockâ€‘Based | Possible | Low      | Medium              |
| Timestamp  | No       | High     | Medium              |
| OCC        | No       | Medium   | High (low conflict) |
| MVCC       | No       | Low      | Very High           |

---

## ğŸ¯ Key Takeaways

* Concurrency control preserves **correctness**
* Different mechanisms suit different workloads
* MVCC is widely used in **modern databases**
* Locking is simplest but can cause deadlocks

---

## âœ… Examâ€‘Friendly Summary

* 2PL â†’ Serializability
* Strict 2PL â†’ Recoverability
* Timestamp â†’ Deadlock free
* OCC â†’ Validation at commit
* MVCC â†’ Snapshot isolation

---

ğŸ“Œ **This README is ready for GitHub upload, revision, and direct download.**
