# ğŸ“˜ Database Normalization â€“ Complete Guide (1NF to 5NF)

This README explains **1NF, 2NF, 3NF, BCNF, 4NF, 5NF**, along with **Lossy vs Lossless Decomposition** and **Dependency Preserving Decomposition** in **simple language** with **clear example tables**.

---

## ğŸ“Œ What is Normalization?

**Normalization** is the process of organizing data in a database to:

* Reduce data redundancy
* Avoid update, insert, and delete anomalies
* Improve data integrity

Normalization is achieved by applying **Normal Forms** step by step.

---

## ğŸ”¹ First Normal Form (1NF)

### Rule

A table is in **1NF** if:

* Each column contains **atomic (indivisible) values**
* No **repeating groups** or multiâ€‘valued attributes

### âŒ Not in 1NF

| StudentID | Name  | Subjects      |
| --------- | ----- | ------------- |
| 1         | Rahul | Math, Science |
| 2         | Anita | English       |

âŒ `Subjects` has multiple values

### âœ… Converted to 1NF

| StudentID | Name  | Subject |
| --------- | ----- | ------- |
| 1         | Rahul | Math    |
| 1         | Rahul | Science |
| 2         | Anita | English |

---

## ğŸ”¹ Second Normal Form (2NF)

### Rule

A table is in **2NF** if:

* It is already in **1NF**
* **No partial dependency** (nonâ€‘key attribute depends on only part of a composite key)

### âŒ Not in 2NF

**Primary Key:** (StudentID, CourseID)

| StudentID | CourseID | StudentName | CourseName |
| --------- | -------- | ----------- | ---------- |
| 1         | C1       | Rahul       | DBMS       |
| 2         | C2       | Anita       | OS         |

âŒ `StudentName` depends only on StudentID
âŒ `CourseName` depends only on CourseID

### âœ… Converted to 2NF

**Student Table**

| StudentID | StudentName |
| --------- | ----------- |
| 1         | Rahul       |
| 2         | Anita       |

**Course Table**

| CourseID | CourseName |
| -------- | ---------- |
| C1       | DBMS       |
| C2       | OS         |

**Enrollment Table**

| StudentID | CourseID |
| --------- | -------- |

---

## ğŸ”¹ Third Normal Form (3NF)

### Rule

A table is in **3NF** if:

* It is already in **2NF**
* **No transitive dependency** (nonâ€‘key attribute depends on another nonâ€‘key attribute)

### âŒ Not in 3NF

| EmpID | EmpName | DeptID | DeptName |
| ----- | ------- | ------ | -------- |
| 1     | Ravi    | D1     | HR       |
| 2     | Meena   | D2     | IT       |

âŒ EmpID â†’ DeptID â†’ DeptName

### âœ… Converted to 3NF

**Employee Table**

| EmpID | EmpName | DeptID |
| ----- | ------- | ------ |

**Department Table**

| DeptID | DeptName |
| ------ | -------- |

---

## ğŸ”¹ Boyceâ€“Codd Normal Form (BCNF)

### Rule

A table is in **BCNF** if:

* It is in **3NF**
* **Every determinant is a candidate key**

### âŒ Not in BCNF

| Student | Course | Instructor |
| ------- | ------ | ---------- |
| A       | DBMS   | Prof X     |
| B       | OS     | Prof Y     |

**FDs:**

* Student, Course â†’ Instructor
* Instructor â†’ Course âŒ

Instructor is not a candidate key

### âœ… Converted to BCNF

**Instructor Table**

| Instructor | Course |
| ---------- | ------ |

**Student Course Table**

| Student | Instructor |
| ------- | ---------- |

---

## ğŸ”¹ Lossless Decomposition

### Meaning

Decomposition is **lossless** if:

* Original table can be **perfectly reconstructed** using JOIN

### Condition

At least one common attribute must be a **key** in one of the tables

### Example (Lossless)

| EmpID | EmpName | DeptID |

Split into:

* Emp(EmpID, EmpName)
* Dept(EmpID, DeptID)

JOIN restores original table âœ…

---

## ğŸ”¹ Lossy Decomposition

### Meaning

Decomposition is **lossy** if:

* JOIN produces **extra or missing data**

### Example (Lossy)

Split into:

* Emp(EmpName, DeptID)
* Dept(DeptID, Location)

âŒ EmpID lost â†’ incorrect reconstruction

---

## ğŸ”¹ Dependency Preserving Decomposition

### Meaning

All **functional dependencies** can be checked **without joining tables**

### Example

FDs:

* EmpID â†’ EmpName
* DeptID â†’ DeptName

After decomposition, dependencies still exist in individual tables âœ…

---

## ğŸ”¹ Fourth Normal Form (4NF)

### Rule

A table is in **4NF** if:

* It is in **BCNF**
* No **multiâ€‘valued dependency**

### âŒ Not in 4NF

| Student | Skill  | Hobby  |
| ------- | ------ | ------ |
| A       | Java   | Music  |
| A       | Python | Sports |

Skill and Hobby are independent

### âœ… Converted to 4NF

**Student Skills**

| Student | Skill |

**Student Hobbies**

| Student | Hobby |

---

## ğŸ”¹ Fifth Normal Form (5NF)

### Rule

A table is in **5NF** if:

* It cannot be decomposed further **without losing information**
* Handles **join dependencies**

### Example

| Supplier | Product | Project |
| -------- | ------- | ------- |

Split into:

* Supplierâ€“Product
* Productâ€“Project
* Supplierâ€“Project

Only valid combinations remain after JOIN

---

## ğŸ“Š Normal Forms Summary

| Normal Form | Eliminates              |
| ----------- | ----------------------- |
| 1NF         | Repeating groups        |
| 2NF         | Partial dependency      |
| 3NF         | Transitive dependency   |
| BCNF        | Nonâ€‘key determinants    |
| 4NF         | Multiâ€‘valued dependency |
| 5NF         | Join dependency         |

---

## âœ… Key Takeaways

* Normalization improves data quality
* Each normal form solves a specific problem
* Higher normal forms are used only when required
* 3NF or BCNF is sufficient for most realâ€‘world systems

---

ğŸ“Œ **This README is GitHubâ€‘ready and downloadable.**
